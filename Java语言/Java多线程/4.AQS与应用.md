# 阻塞队列

## 概述

### 简介

阻塞队列是线程池的重要组成部分

如果队列为空，则取数据会一直阻塞；如果队列满了，则插入数据会一直阻塞。其实体现了生产者消费者模式

阻塞队列是具有阻塞功能的队列，通常阻塞队列的一端给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，生产者消费者都可以是多线程的。

![image-20210606153219428](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153219428.png)

### 继承体系图

![image-20210606153040648](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210606153040648.png)

## 常用方法

### 抛出异常方法

```java
BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 该队列最大为3
System.out.println(blockingQueue.add("a"));
System.out.println(blockingQueue.add("b"));
System.out.println(blockingQueue.add("c"));
//抛出异常:java.lang.IllegalStateException: Queue full
System.out.println(blockingQueue.add("x"));
```

### 返回特殊值方法

```java
BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
System.out.println(blockingQueue.offer("a"));
System.out.println(blockingQueue.offer("b"));
System.out.println(blockingQueue.offer("c"));
System.out.println(blockingQueue.offer("d")); // false
```

### 阻塞方法

+ take()方法：获取并移除队列的头节点，一旦执行take的时候，队列里无数据，则阻塞，直到队列里有数据
+ put()方法：插入数据。如果队列已满，就无法插入，即阻塞，直到队列里有了空闲空间

```java
BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
blockingQueue.put("a");
blockingQueue.put("b");
blockingQueue.put("c");
//blockingQueue.put("d"); //队列满了，该线程会等待
blockingQueue.take();
blockingQueue.take();
blockingQueue.take();
//不消费完线程，就阻塞掉
blockingQueue.take();
```

### 超时方法

```java
BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
System.out.println(blockingQueue.offer("a"， 2L， TimeUnit.SECONDS));
System.out.println(blockingQueue.offer("a"， 2L， TimeUnit.SECONDS));
System.out.println(blockingQueue.offer("a"， 2L， TimeUnit.SECONDS));
//只阻塞2s，就会返回false
System.out.println(blockingQueue.offer("a"， 2L， TimeUnit.SECONDS));
```

## 常见类

### ArrayBlockingQueue

有界阻塞队列，创建时需要指定容量

```java
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
```



### LinkedBlockingQueue

有界阻塞队列，但是最大是Integer.MAX_VALUE，可以认为是无界队列



### SynchronousQueue

+ 容量为0，不需要存储元素，没有头节点，也就没有了peek()方法
+ 直接传递的并发数据结构
+ 是线程池Executors.newCachedThreadPool()使用的阻塞队列

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class Main{
    public static void main(String[] args) {
        //同步队列不存储，只能生产一个就消费一个
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName()+" put");
                blockingQueue.put("3");
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        }，"t1").start();
        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            try {
                System.out.println(blockingQueue.take());
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        }，"t2").start();
    }
}
```

### PriorityBlockingQueue

# AQS

## 概述

抽象的队列同步器

是用来构建锁或者其他同步器组件的重量级基础框架及整个JUC体系的基石。通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类型变量表示持有锁的状态

基本上CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock、CyclicBarrier都和AQS有关

**应用**

```java
// 实现一个非独占锁，当有线程调用await时陷入阻塞，只有某个线程调用了signal时才全部放行
public class MyLock {
    private final Sync sync = new Sync();

    private static final class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected int tryAcquireShared(int arg) {
            return getState() == 1 ? 1 : -1; //  state初始化为0，代表会阻塞，为1时代表线程放行
        }

        @Override
        protected boolean tryReleaseShared(int arg) {
            setState(1); // 后面获取锁的线程不需要阻塞了
            return true; // 把之前等待的线程唤醒
        }
    }

    public void await() {
        sync.acquireShared(0);
    }

    public void signal() {
        sync.releaseShared(0);
    }

    public static void main(String[] args) throws InterruptedException {
        MyLock myLock = new MyLock();
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println("尝试获取锁");
                myLock.await();
                System.out.println("获取成功，开始执行！");
            }).start();
        }
        TimeUnit.SECONDS.sleep(3);
        myLock.signal();
    }
}
```

## state

```java
private volatile int state;
```

会被并发地修改，所以所有修改state的方法都需要保证线程安全

```java
protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
```

在ReentrantLock中，state代表锁的占有情况，包括**可重入计数**

当state为0时，标识该Lock不被任何线程所占有

## FIFO队列

- 这个队列用来存放等待的线程，AQS就是一个排队管理器，当多个线程争用同一把锁时，必须有一个排队机制把那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁
- AQS会维护一个等待的线程队列，把线程都放在这个队列里
- head是拿到锁的线程：

![image-20210607145130742](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210607145130742.png)

## 重要方法

### 获取方法

获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）

### 释放方法

释放操作不会阻塞

# 并发工具类

## CountDownLatch

+ 线程调用`countDown`方法会将计数器减一(调用`countDown`不会阻塞)
+ 当一个或多个线程调用`await`方法时，调用线程会被阻塞
+ 当计数器为零时，因为调用了`await`方法而被阻塞的线程会被唤醒，继续执行
+ CountDownLatch不能重用

用法一：一个线程等待多个线程都执行完毕，再继续自己的工作

```java
//例如启动程序，对外发布服务时，应该所有的都检查完毕（检查数据有没有完毕等前置流程）才进入下一个环节
//主线程等待所有线程都执行完毕才结束
public static void main(String[] args) throws InterruptedException {
    CountDownLatch countDownLatch = new CountDownLatch(6);
    for (int i = 0; i < 6; i++) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 离开");
            countDownLatch.countDown();
        }， String.valueOf(i)).start();
    }
    countDownLatch.await(); // 必须要减到0才能解除
    System.out.println("全部结束咯");
}
```

用法二：多个线程等待某一个线程的信号，同时开始执行。

```java
// 例如进行压测，创建很多线程应该先等待，再一个统一的时间再过去
public static void main(String[] args) throws InterruptedException {
    CountDownLatch countDownLatch = new CountDownLatch(1);
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    for (int i = 0; i < 5; i++) {
        int finalI = i;
        executorService.submit(() -> {
            System.out.println(finalI + "准备完毕");
            try {
                countDownLatch.await();
                System.out.println(finalI + "开始跑步");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
    TimeUnit.SECONDS.sleep(5);         // 检查场地等
    System.out.println("比赛开始！");
    countDownLatch.countDown();
}
```

## Semaphore

+ 可以用来限制或管理数量有限资源的使用情况。实际上就相当于PV操作
+ 当一个线程调用acquire（获取），要么成功获得信号量（信号量-1），要么阻塞到有线程释放信号量
+ release（释放），实际会将信号量的值+1，然后唤醒等待的线程
+ 可以选择公平或者非公平实现：`public Semaphore(int permits, boolean fair)`

```java
Semaphore semaphore = new Semaphore(3);
for (int i = 0; i < 6; i++) {
    new Thread(()->{
        try {
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName()+" 抢到车位");
            TimeUnit.SECONDS.sleep(2);
            System.out.println(Thread.currentThread().getName()+" 离开车位");
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            semaphore.release();
        }
    }，String.valueOf(i)).start();
}
```

## CyclicBarrier

+ 可循环(`Cyclic`)使用的屏障(`Barrier`)
+ 让一组线程到达一个屏障(同步点)时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续干活
+ 线程进入屏障是通过`CyclicBarrier`的`await()`方法

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
        System.out.println("大威天龙!");
    });
    for (int i = 0; i < 7; i++) {
        int finalI = i+1;
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+ " 收集龙珠"+finalI );
            try {
                cyclicBarrier.await();
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
            catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        },"thread"+String.valueOf(i)).start();
    }
}
```

