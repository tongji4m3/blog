> 整理自《UNIX网络编程 卷1：套接字联网API》第三版

# TCP连接的建立和终止

## 三次握手

1. 服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为**被动打开**
2. 客户通过调用connect发起**主动打开**，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。
3. 服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。
4. 客户必须确认服务器的SYN

![image-20210603165512924](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png)

## 四次挥手

1. 某个应用进程（假设是客户端）首先调用close，执行**主动关闭**，于是发送一个FIN，表示数据发送完毕
2. 接收到这个FIN的对端（假设是服务器）执行**被动关闭**，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收
3. 一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN
4. 执行主动关闭的那端会发送ACK确认这个FIN

![image-20210603165546769](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png)

## TCP状态转换图

用粗实线表示客户状态转换，粗虚线表示服务器状态转换。

接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节

例子1 **客户端建立连接**：

当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态

例子2 **客户端、服务器断开连接**：

如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态

但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态

![image-20210603170310342](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png)

## 完整流程

![image-20210603171012559](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png)

## TIME_WAIT状态

执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）

TIME_WAIT状态存在原因：

1. 可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK
2. 允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。

## 并发服务器

主服务器循环通过派生一个子进程来处理每个新的连接

当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求

![image-20210603172737267](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png)

TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节

我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）

对于同一个本地端口（21）存在三个套接字：

+ 如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程
+ 如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程
+ 所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）

## TCP输出

应用进程写数据到一个TCP套接字中时发生的步骤：

![image-20210603185857129](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png)

每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区

因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。

这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止

本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。

# 简单案例

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png" alt="image-20210603191611037" style="zoom: 67%;" />



![image-20210603203304963](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png)

**正常终止步骤**

1. 当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回
2. 当str_cli函数返回到客户的main函数时，main通过调用exit终止
3. 进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态
4. 当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数
5. 服务器子进程通过调用exit来终止
6. 服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态

## 客户端

```c
#include	"unp.h"

int
main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_in	servaddr;

	if (argc != 2)
		err_quit("usage: tcpcli <IPaddress>");

    // 创建一个套接字，返回描述符
	sockfd = Socket(AF_INET, SOCK_STREAM, 0);

    // 填入服务器的IP地址和端口号
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

    // 和服务器建立TCP连接
	Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

	str_cli(stdin, sockfd);

	exit(0); // 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符
}

void
str_cli(FILE *fp, int sockfd)
{
    char	sendline[MAXLINE], recvline[MAXLINE];

    while (Fgets(sendline, MAXLINE, fp) != NULL) {

        Writen(sockfd, sendline, strlen(sendline));

        if (Readline(sockfd, recvline, MAXLINE) == 0)
            err_quit("str_cli: server terminated prematurely");

        Fputs(recvline, stdout);
    }
}
```

客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。

## 服务器端

```c
#include	"unp.h"

int main(int argc, char **argv)
{
	int					listenfd, connfd;
	pid_t				childpid;
	socklen_t			clilen;
	struct sockaddr_in	cliaddr, servaddr;

    // 创建套接字
	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);

    // 调用bind函数绑定端口号
	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

    // 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收
	Listen(listenfd, LISTENQ);

	for ( ; ; ) {
		clilen = sizeof(cliaddr);
        // 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受
        // TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd
        // 该描述符用于与新连接的那个客户通信
        // accept为每个连接到本服务器的客户返回一个新描述符
        // 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数
		connfd = Accept(listenfd, (SA *) &cliaddr, &clilen);

		if ( (childpid = Fork()) == 0) {	
			Close(listenfd);	
			str_echo(connfd);	
			exit(0);
		}
        // 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）
		Close(connfd);			
	}
}

void str_echo(int sockfd)
{
    ssize_t		n;
    char		buf[MAXLINE];

    again:
    // 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程
    while ( (n = read(sockfd, buf, MAXLINE)) > 0)
        Writen(sockfd, buf, n);

    if (n < 0 && errno == EINTR)
        goto again;
    else if (n < 0)
        err_sys("str_echo: read error");
}
```

当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。

另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。

## 并发服务器

是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程

```c
pid_t pid;
int listenfd, connfd;
listenfd = Socket();
Bind(listenfd);
Listen(listenfd, backlog);

for(;;) {
    connfd = Accept(listenfd);
    // 子进程进入if执行
    if ((pid == Fork()) == 0) {
        Close(listenfd);
        processHandler(connfd); // 处理请求
        Close(connfd);
        exit(0);
    }
    Close(connfd);
}
```

当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。

对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。

![image-20210603200912778](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png)

![image-20210603200853359](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png)

![image-20210603200933250](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png)

## 常见函数

### Socket函数

```c#
int socket(int family, in type, int protocol);
```

指定期望的通信协议类型（例如使用IPv4的TCP）

socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd

### connect函数

TCP客户用connect函数来建立与TCP服务器的连接

```c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
```

sockfd是由socket函数返回的套接字描述符

servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）

客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口

如果是TCP套接字，调用connect函数将触发TCP的三次握手过程

### bind函数

```c
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
```

myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一

### listen函数

```c
int listen(int sockfd, int backlog);
```

listen函数仅由TCP服务器调用，作用：

1. 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态
2. 本函数第二个参数规定内核应该为相应套接字排队的最大连接个数

内核为任何一个给定的监听套接字维护两个队列：

1. **未完成连接队列**。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)
2. **已完成连接队列**。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png" alt="image-20210603193151337" style="zoom:67%;" />

每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。

当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他

在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小

### accept函数

```c
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
```

accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。

如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接

称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。

### close函数

```c
int close(int sockfd);
```

关闭套接字，终止TCP连接

默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。

然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手

### fork函数

fork函数是Unix派生新进程的唯一方法

```c
pid_t fork(void); // 返回在子进程中为0，在父进程中为子进程ID，若出错为-1
```

调用fork函数一次，它返回两次：

1. 它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID
2. 在子进程又返回一次，返回值是0

因此返回值本身告知当前进程是父进程还是子进程

父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字

fork函数典型用法：

1. 一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。
2. 一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。

# IO模型

## 概述

输入操作通常包括两个不同的阶段：

1. 等待数据准备好
2. 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

**UDP套接字编程**

下面的IO模型拿UDP举例，因为数据准备好读取的概念比较简单：要么整个数据报已经收到，要么还没有。所以先简述UDP套接字编程

客户不与服务器建立连接，而是只使用sendto函数给服务器发送数据报，其中必须指定目的地。类似的，服务器不接受来自客户的连接，而是只管调用recvfrom函数，等待来自某个客户的数据到达。recvfrom将与所接收的数据报一道返回客户的协议地址，因此服务器可以把响应发送给正确的客户。

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604183925749.png" alt="image-20210604183925749" style="zoom:67%;" />

## 阻塞式IO模型

把recvfrom视为系统调用，因为要区分应用进程和内核。它一般都会从在应用进程空间中运行切换到在内核空间中运行，一段时间后再切换回来

进程调用recvfrom，其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。recvfrom成功返回后，应用进程开始处理数据报。

![image-20210604184115118](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604184115118.png)

## 非阻塞式IO模型

进程把一个套接字设置成非阻塞是通知内核：当所请求的IO操作需要把本进程阻塞时，不阻塞了，而是返回一个错误

前三次调用recvfrom时没有数据可返回，因此内核立即返回一个RWOULDBLOCK错误。第四次调用recvfrom时已有一个数据报准备好，它被复制到应用进程缓冲区，于是recvfrom成功返回。我们接着处理数据。

当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，称为轮询。应用程序持续轮询内核，以查看某个操作是否就绪，往往会消耗大量的CPU时间

![image-20210604184548171](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604184548171.png)

## IO复用模型

select、poll的IO复用：进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个IO条件就绪（输入已经准备好或描述符已能承接更多的输出），它就通知进程。

适用于：

+ 客户处理多个描述符（通常是交互式输入和网络套接字）
+ TCP服务器既要处理监听套接字，又要处理已连接套接字

有了IO复用，我们可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的IO系统调用上。

我们阻塞于select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据复制到应用进程缓冲区。

使用select的优势在于我们可以等待多个描述符就绪。

![image-20210604184847044](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604184847044.png)

## 信号驱动IO模型

也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们

首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用立即返回，我们进程继续工作，即没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。

无论如何处理SIGIO信号，这种模型优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取

![image-20210604185348944](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604185348944.png)

## 异步IO模型

告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。

与信号驱动模型的主要区别在于：信号驱动IO由内核通知我们何时可以启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成。

我们调用aio_read函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。

本例子中我们假设要求内核在操作完成时产生某个信号。该信号直到数据已复制到应用进程缓冲区才产生。

![image-20210604191046411](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604191046411.png)

## IO模型比较

+ 同步IO操作：导致请求进程阻塞，直到IO操作完成
+ 异步IO操作：不导致请求进程阻塞

前四种同步IO模型的主要区别在第一阶段，因为他们第二阶段是一样的：在数据从内核复制到调用者缓冲区期间，进程阻塞与recvfrom调用。相反，异步IO模型在这两阶段都要处理

![image-20210604191058943](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604191058943.png)

阻塞式IO模型、非阻塞式IO模型、IO复用模型、信号驱动IO模型都是同步IO模型，因为其中真正的IO操作(recvfrom)将阻塞进程。

# select函数

## 概述

该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

例子：我们可以调用select，告知内核仅在下列情况发生时才返回：

+ 集合{1，4，5}中的任何描述符准备好读；
+ 集合{2，7}中的任何描述符准备好写；
+ 集合{1，4}中的任何描述符有异常条件待处理；
+ 已经历10.2s

也就是说，我们调用select告知内核对哪些描述符（就读、写或异常条件）感兴趣，以及等待多长时间。

```c
int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```

timeout告知内核等待所指定描述符中的任何一个就绪可花多长时间，可赋值为三种情况：

1. 永远等待下去：仅在有一个描述符准备好IO才返回。为此，我们把该参数设置为空指针。
2. 等待一段固定时间：在有一个描述符准备好IO才返回，但是不超过指定参数的时间。
3. 根本不等待：检查描述符后立即返回，这称为轮询。参数指定为0.

readset、writeset、exceptset指定我们要让内核测试读、写和异常条件的描述符，如果对某一个条件不感兴趣，就可以把它设为空指针。

maxfdp1参数指定待测试的描述符个数，它的值是待测试的最大描述符加1。

当函数返回时，结果将指示哪些描述符已就绪。

头文件<sys/select.h>中定义的FD_SETSIZE常量值是数据类型fd_set中的描述符总数（通常是1024）

## 客户端程序

> 该函数原书描述还存在问题，但是实在看不下去了..

![image-20210604193654363](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604193654363.png)

8-13行：**调用select**

我们只需要一个用于检查可读性的描述符集。该集合由FD_ZERO初始化，并用FD_SET打开两位：一位对应于标准IO文件指针fp，一位对应于套接字sockfd。fileno函数把标准IO文件指针转换为对应的描述符。因为select函数只工作在描述符上。

计算两个描述符中的较大者后，调用select。在该调用中，写集合指针和异常集合指针都是空指针。最后一个参数（时间限制）也是空指针，因为我们希望本调用阻塞到某个描述符就绪为止。

14-18行：**处理可读套接字**

如果在select返回时套接字是可读的，就执行对应操作

19-23行：**处理可读输入**

如果标准输入可读，就执行相应操作

## 服务器程序

把之前的案例重写为使用select来处理任意个客户的单进程程序。

![image-20210604194813136](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604194813136.png)

服务器只维护一个读描述符集，假设服务器是前台启动的，那么描述符0、1、2分别被置为标准输入、标准输出、标准错误输出。所以监听套接字的第一个可用描述符是3

client数组中含有每个客户的已连接套接字描述符，初始化为-1

![image-20210604195011425](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195011425.png)

当第一个客户与服务器建立连接时，监听描述符变为可读，我们的服务器于是调用accept

![image-20210604195113032](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195113032.png)

我们的服务器必须在client数组中记住每个新的已连接描述符，并把他加到描述符集中去：

![image-20210604195226480](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195226480.png)

随后第二个客户与服务器建立连接：

![image-20210604195258834](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195258834.png)

接着假设第一个客户终止连接。该客户的TCP发生一个FIN，使得描述符4变得可读。当服务器读这个已连接套接字时，read将返回0。于是关闭该套接字并且把client[0]置为-1，把描述符集中描述符4的位设置位0

![image-20210604195506423](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210604195506423.png)

总之，有客户到达时，我们在client数组中的第一个可用项（值为-1的项）中记录其已连接套接字的描述符。并且还必须把这个已连接描述符加到读描述符集中

```c
listenfd = Socket(AF_INET, SOCK_STREAM, 0);
Bind(listenfd);
Listen(listenfd, LISTENQ);

for ( ; ; ) {
    nready = Select(maxfd+1, &rset, NULL, NULL, NULL);
    // 处理新连接接入
    if (FD_ISSET(listenfd, &rset)) {	
        connfd = Accept(listenfd);
    }
    // 检查现有连接
    for (i = 0; i <= maxi; i++) {	
        if (FD_ISSET(sockfd, &rset)) {
            if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {
            } else
                Writen(sockfd, buf, n);
        }
    }
}
```

- **创建监听套接字并调用select进行初始化**
- **阻塞于select**：select等待某个事件发生：或是新连接建立，或是数据、FIN或RST到达
- **accept新的连接**：如果监听套接字变为可读，则已建立一个新的连接。我们调用accept并更新相应的数据结构。
- **检查现有连接**：对于每个现有的客户连接，我们要测试其描述符是否在select返回的描述集里。