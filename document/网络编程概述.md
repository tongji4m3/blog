# 简单案例

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603191611037.png" alt="image-20210603191611037" style="zoom: 67%;" />



![image-20210603203304963](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603203304963.png)

**正常终止步骤**

1. 当我们键入EOF字符时，fgets返回一个空指针，于是str_cli函数返回
2. 当str_cli函数返回到客户的main函数时，main通过调用exit终止
3. 进程终止处理的部分工作是关闭所有打开的描述符，因此客户打开的套接字由内核关闭，这导致客户TCP发送一个FIN给服务器，服务器TCP则以ACK响应。至此，服务器套接字处于CLOSE_WAIT状态，客户套接字处于FIN_WAIT_2状态
4. 当服务器TCP接收FIN时，服务器子进程阻塞于readline调用，于是readline返回0，这导致str_echo函数返回服务器子进程的main函数
5. 服务器子进程通过调用exit来终止
6. 服务器子进程中打开的所有描述符随之关闭，由子进程来关闭已连接套接字会引发TCP连接终止序列的最后两个分节：一个从服务器到客户的FIN和一个从客户到服务器的ACK。至此连接完全终止，客户端套接字进入TIME_WAIT状态

## 客户端

```c
#include	"unp.h"

int
main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_in	servaddr;

	if (argc != 2)
		err_quit("usage: tcpcli <IPaddress>");

    // 创建一个套接字，返回描述符
	sockfd = Socket(AF_INET, SOCK_STREAM, 0);

    // 填入服务器的IP地址和端口号
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	Inet_pton(AF_INET, argv[1], &servaddr.sin_addr);

    // 和服务器建立TCP连接
	Connect(sockfd, (SA *) &servaddr, sizeof(servaddr));

	str_cli(stdin, sockfd);

	exit(0); // 终止程序运行，Unix在进程终止时总是关闭该进程所有打开的描述符
}

void
str_cli(FILE *fp, int sockfd)
{
    char	sendline[MAXLINE], recvline[MAXLINE];

    while (Fgets(sendline, MAXLINE, fp) != NULL) {

        Writen(sockfd, sendline, strlen(sendline));

        if (Readline(sockfd, recvline, MAXLINE) == 0)
            err_quit("str_cli: server terminated prematurely");

        Fputs(recvline, stdout);
    }
}
```

客户调用st_cli函数，该函数将阻塞于fgets调用，因为我们还未输入任何数据。

## 服务器端

```c
#include	"unp.h"

int main(int argc, char **argv)
{
	int					listenfd, connfd;
	pid_t				childpid;
	socklen_t			clilen;
	struct sockaddr_in	cliaddr, servaddr;

    // 创建套接字
	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family      = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port        = htons(SERV_PORT);

    // 调用bind函数绑定端口号
	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));

    // 把套接字转换成一个监听套接字，这样来自客户端的外来连接可以在该套接字由内核接收
	Listen(listenfd, LISTENQ);

	for ( ; ; ) {
		clilen = sizeof(cliaddr);
        // 服务器进程在accept调用中被置于休眠状态，等待某个客户连接的到达并被内核接受
        // TCP使用三次握手来建立连接，握手完毕后accept返回。一个已连接描述符connfd
        // 该描述符用于与新连接的那个客户通信
        // accept为每个连接到本服务器的客户返回一个新描述符
        // 该服务器一次只能处理一个客户。如果多个客户连接同时到达，系统内核在某个最大数量的限制下把他们排入队列，然后每次返回一个给accept函数
		connfd = Accept(listenfd, (SA *) &cliaddr, &clilen);

		if ( (childpid = Fork()) == 0) {	
			Close(listenfd);	
			str_echo(connfd);	
			exit(0);
		}
        // 服务器调用close关闭与客户的连接，引发四次挥手操作。（当然这里引用计数不为0，实际close操作在子进程完成）
		Close(connfd);			
	}
}

void str_echo(int sockfd)
{
    ssize_t		n;
    char		buf[MAXLINE];

    again:
    // 如果客户关闭连接，那么接收到客户的FIN将导致服务器子进程的read函数返回0，将导致str_echo返回，从而终止子进程
    while ( (n = read(sockfd, buf, MAXLINE)) > 0)
        Writen(sockfd, buf, n);

    if (n < 0 && errno == EINTR)
        goto again;
    else if (n < 0)
        err_sys("str_echo: read error");
}
```

当服务器端accept函数返回时，服务器调用fork，再有子进程调用str_echo。该函数调用readline，readline调用read，而read在等待客户送入一行文本期间阻塞。

另一方面，服务器父进程再次调用accept并阻塞，等待下一个客户连接。

## 并发服务器

是在同时有大量的客户连接到同一个服务器上时用于提供并发性的一种技术，每个客户连接都迫使服务器为他fork一个新的进程

```c
pid_t pid;
int listenfd, connfd;
listenfd = Socket();
Bind(listenfd);
Listen(listenfd, backlog);

for(;;) {
    connfd = Accept(listenfd);
    // 子进程进入if执行
    if ((pid == Fork()) == 0) {
        Close(listenfd);
        processHandler(connfd); // 处理请求
        Close(connfd);
        exit(0);
    }
    Close(connfd);
}
```

当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（提供已连接套接字connfd)，父进程则等待另一个连接（通过监听套接字listenfd)。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。

对一个TCP套接字调用close会导致发送一个FIN，随后是正常的四次挥手，那么为什么父进程对connfd调用close没有终止它与客户的连接？因为每个文件或套接字都有一个引用计数（是当前打开着的引用该文件或套接字的描述符的个数）。套接字真正的清理和资源释放要等到引用计数值为0时才发生，即会在子进程也关闭connfd时发生。

![image-20210603200912778](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200912778.png)

![image-20210603200853359](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200853359.png)

![image-20210603200933250](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603200933250.png)

## 常见函数

### Socket函数

```c#
int socket(int family, in type, int protocol);
```

指定期望的通信协议类型（例如使用IPv4的TCP）

socket函数在成功时返回一个小的非负整数值，与文件描述符类似，称为套接字描述符，简称sockfd

### connect函数

TCP客户用connect函数来建立与TCP服务器的连接

```c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
```

sockfd是由socket函数返回的套接字描述符

servaddr、addrlen是指向套接字地址结构的指针和该结构的大小（结构中含有服务器的IP地址和端口号）

客户调用connect函数时不需要调用bind函数，因为如果需要，内核会确定源ip地址，并选择一个临时端口作为源端口

如果是TCP套接字，调用connect函数将触发TCP的三次握手过程

### bind函数

```c
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
```

myaddr、addrlen是指向套接字地址结构的指针和该结构的大小（可以指定要绑定的IP地址和端口号），如果要绑定IP地址，则该IP地址必须属于其所在主机的网络接口之一

### listen函数

```c
int listen(int sockfd, int backlog);
```

listen函数仅由TCP服务器调用，作用：

1. 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是一个调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。即调用listen函数导致套接字从CLOSED状态转换成LISTEN状态
2. 本函数第二个参数规定内核应该为相应套接字排队的最大连接个数

内核为任何一个给定的监听套接字维护两个队列：

1. **未完成连接队列**。每个这样的SYN分节对应其中的一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三次握手过程。这些套接字处于SYN_RCVD状态（在三次握手正常完成的前提下，未完成连接队列中的任何一项在其中的存留时间就是一个RTT)
2. **已完成连接队列**。每个已完成TCP三次握手过程的客户对应其中一项。这些套接字处于ESTABLISHED状态

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603193151337.png" alt="image-20210603193151337" style="zoom:67%;" />

每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。

当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三次握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器SYN的ACK）到达或该项超时为止。如果三次握手正常完成，该项就从未完成连接队列移动到已完成连接队列的队尾。当进程调用accept时，已完成连接队列中的队头项就返回给进程，或者如果该队列为空，那么进程将处于休眠状态，直到TCP在该队列中放入一项才唤醒他

在三次握手完成之后，但在服务器调用accept之前到达的数据应由服务器TCP排队，最大数据量为相应已连接套接字的接受缓冲区大小

### accept函数

```c
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
```

accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程置为休眠状态。

如果accept成功。那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接

称第一个参数为监听套接字描述符，返回值为已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，他在该服务器的生命周期内一直存在，内核为每个由服务器进程接受的客户连接创建一个已连接套接字（对于他的三次握手过程已经完成）。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭。

### close函数

```c
int close(int sockfd);
```

关闭套接字，终止TCP连接

默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的参数。

然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接四次挥手

### fork函数

fork函数是Unix派生新进程的唯一方法

```c
pid_t fork(void); // 返回在子进程中为0，在父进程中为子进程ID，若出错为-1
```

调用fork函数一次，它返回两次：

1. 它在调用进程（父进程）中返回一次，返回值是新派生进程（子进程）的进程ID
2. 在子进程又返回一次，返回值是0

因此返回值本身告知当前进程是父进程还是子进程

父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。如果父进程在调用accept之后调用fork，所接受的已连接套接字随后就在父进程和子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字

fork函数典型用法：

1. 一个进程创建一个自身的副本，这样每个副本都可以在来一个副本执行其他任务的同时处理各自的某个操作，这是网络服务器的典型用法。
2. 一个进程想要执行另一个程序。该进程调用fork创建一个自身的副本，其中一个副本（子进程）调用exec把自身替换成新的程序。是shell等程序的典型用法。

# TCP连接的建立和终止

## 三次握手

1. 服务器必须准备好接受外来的连接。通常是通过调用socket、bind和listen三个函数完成，此时为**被动打开**
2. 客户通过调用connect发起**主动打开**，这导致客户端TCP发送一个SYN，告诉服务器自己的初始序列号（不带数据）。
3. 服务器必须确认（ACK）客户的SYN，同时自己也要发送一个SYN，含有服务器将在同一连接中发送数据的初始序列号。
4. 客户必须确认服务器的SYN

![image-20210603165512924](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165512924.png)

## 四次挥手

1. 某个应用进程（假设是客户端）首先调用close，执行**主动关闭**，于是发送一个FIN，表示数据发送完毕
2. 接收到这个FIN的对端（假设是服务器）执行**被动关闭**，给客户发送回ACK。FIN的接收意味着服务器端在相应连接上再无额外数据可接收
3. 一段时间后（这段时间内，服务器端仍然可以向客户端发送数据，称为半关闭状态），服务器端也将调用close关闭他的套接字，它会像客户端也发送一个FIN
4. 执行主动关闭的那端会发送ACK确认这个FIN

![image-20210603165546769](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603165546769.png)

## TCP状态转换图

用粗实线表示客户状态转换，粗虚线表示服务器状态转换。

接收表示该状态转换在接受到什么分节时发生，发送表示该状态转换会发送什么分节

例子1 **客户端建立连接**：

当某个应用程序在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED，这个状态通常是数据传送发生时的状态

例子2 **客户端、服务器断开连接**：

如果某个应用进程在接收到一个FIN之前调用close（主动关闭），则转换到FIN_WAIT_1状态

但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN（被动关闭），那就转换到CLOSE_WAIT状态

![image-20210603170310342](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603170310342.png)

## 完整流程

![image-20210603171012559](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603171012559.png)

## TIME_WAIT状态

执行主动关闭的那端会经历该状态，持续时间是2MSL（两倍的最长分节生命期，MSL是任何IP数据报能够在因特网中存活的最长时间）

TIME_WAIT状态存在原因：

1. 可靠地实现TCP全双工连接的终止。假设最终的ACK丢失，服务器将重新发送它的最终FIN，所以客户端必须维护状态信息，以允许它重新发送最终的那个ACK
2. 允许老的重复分节在网络中消逝。假设关闭了一个TCP连接，过一段时间又在相同的IP地址和端口号之间建立另一个连接（称为前一个连接的化身，因为IP、端口号一样）。TCP必须防止来自某个连接的老的重复分组在该连接已终止后再次出现。为做到这一点，TCP就不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT的持续时间的2MSL，就足以让某个方向上的分组最多存活MSL即被丢弃。通过该规则，就能保证每成功建立一个TCP连接，来自该连接先前化身的老的重复分组都已经在网络中消逝了。

## 并发服务器

主服务器循环通过派生一个子进程来处理每个新的连接

当服务器接收并接受这个客户的连接，它fork一个自身的副本，让子进程来处理该客户的请求

![image-20210603172737267](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603172737267.png)

TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点，它必须查看套接字对的所有四个元素才能确定由哪个端点接收某个到达的分节

我们必须在服务器主机上区分监听套接字和已连接套接字。已连接套接字使用与监听套接字相同的本地端口（21）

对于同一个本地端口（21）存在三个套接字：

+ 如果一个分节来自客户端端口1500，目的地为服务器端端口21，被传递到第一个子进程
+ 如果一个分节来自客户端端口1501，目的地为服务器端端口21，被传递到第二个子进程
+ 所有目的端口为21的其他TCP分节被传递给拥有监听套接字的那个最初服务器（父进程）

## TCP输出

应用进程写数据到一个TCP套接字中时发生的步骤：

![image-20210603185857129](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603185857129.png)

每一个TCP套接字有一个发送缓冲区。当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区，如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将置于休眠状态。内核将不从write系统调用返回，直到应用进程缓冲区中所有数据都复制到套接字发送缓冲区

因此，从一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。

这一端的TCP提取套接字发送缓冲区中的数据并把它发送给对端TCP。对端TCP必须确认收到的数据，伴随来自对端的ACK的不断到达，本端TCP至此才能从套接字发送缓冲区中丢弃已确认的数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认为止

本端TCP以MSS大小的块把数据传递给IP，同时给每个数据块安上一个TCP首部已构成TCP分节，IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表项以确定外出接口，然后把数据报传递给相应的数据链路。