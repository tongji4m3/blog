# BIO

## 概述

BIO是一个同步并阻塞的IO模式，**传统的  java.io 包**，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如**File抽象、输入输出流**等。**交互方式是同步、阻塞的方式**，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1890419bbba44f29b0f71f5598c5e111~tplv-k3u1fbpfcp-zoom-1.image)

blocking I/O。同步阻塞模型

由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行处理。

每个线程都需要创建独立的线程，当并发量大时，需要创建大量线程来处理连接，系统资源占用大

代码中的read操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603081447596.png" alt="image-20210603081447596" style="zoom: 67%;" />

## 详解

当服务器进程运行时, 可能会同时监听到多个客户的连接请求。

每当一个客户进程执行以下代码：

```java
Socket client = new Socket("127.0.0.1", 8848);
```

就意味着在远程主机的 8848 端口上, 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。当队列中的连接请求达到了队列的最大容量时, 服务器进程所在的主机会拒绝新的连接请求。只有当服务器进程通过 ServerSocket 的 accept() 方法从队列中取出连接请求, 使队列腾出空位时，队列才能继续加入新的连接请求。

 对于客户进程, 如果它发出的连接请求被加入到服务器的请求连接队列中, 就意味着客户与服务器的连接建立成功, 客户进程从 Socket 构造方法中正常返回。

当客户进程的 Socket构造方法返回成功, 表示客户进程的连接请求被加入到服务器进程的请求连接队列中。 虽然客户端成功返回 Socket对象， 但是还没跟服务器进程形成一条通信线路。必须在服务器进程通过 ServerSocket 的 accept() 方法从请求连接队列中取出连接请求，并返回一个Socket 对象后，服务器进程这个Socket 对象才与客户端的 Socket 对象形成一条通信线路。

ServerSocket 的 accept() 方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的 Socket 对象, 并将它返回。如果队列中没有连接请求，accept() 方法就会一直等待，直到接收到了连接请求才返回。

 接下来，服务器从 Socket 对象中获得输入流和输出流，就能与客户交换数据。

服务器的主线程负责接收客户的连接, 每次接收到一个客户连接, 就会创建一个工作线程, 由它负责与客户的通信

## 示例程序

**Server**

```java
public class BIOServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8848);
        while (true) {
            // 线程在accept调用时处于休眠状态，等待某个客户连接到达并被内核接受
            Socket socket = serverSocket.accept();
            new Thread(() -> handler(socket)).start();
        }
    }

    public static void handler(Socket socket) {
        InputStream inputStream = null;
        try {
            byte[] bytes = new byte[1024];
            inputStream = socket.getInputStream();
            int read;
            while ((read = inputStream.read(bytes)) != -1) {
                System.out.println(new String(bytes, 0, read));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**Client**

```java
public class BIOClient {
    public static void main(String[] args) throws IOException {
        Socket client = new Socket("127.0.0.1", 8848);
        OutputStream outputStream = client.getOutputStream();
        String msg = "Hello Server!";
        outputStream.write(msg.getBytes(StandardCharsets.UTF_8));
        client.close();
    }
}
```

# NIO

## IO操作

应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。

外部设备的直接读写涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，结束中断之后，还需要恢复之前的进程数据和状态等信息。为了减少底层系统的频繁中断所导致的时间损耗、性能损耗，出现了内核缓冲区。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。

上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。在大多数情况下，Linux系统中用户程序的IO读写程序并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。

<img src="https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605150414935.png" alt="image-20210605150414935" style="zoom: 67%;" />

一个完整输入流程的两个阶段：
•应用程序等待数据准备好：第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。
•从内核缓冲区向用户缓冲区复制数据：第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。

## IO多路复用模型

select/epoll系统调用。通过该系统调用，一个用户进程（或者线程）可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。
IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现，有时也称为异步阻塞IO，Java中的Selector属于这种模型。

在IO多路复用模型中通过select/epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。

（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select/epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。

（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。

（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。

（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。

![image-20210605151630414](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210605151630414.png)

通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。

IO多路复用模型的缺点是，本质上select/epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。



## 介绍

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/f1c9e5d2b37d489e959ccd2d7573a713~tplv-k3u1fbpfcp-zoom-1.image)

non-blocking I/O或New IO

同步非阻塞，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。

![image-20210603090056517](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210603090056517.png)

## Channel

+ 类比于IO流，但是具有双向性，既可读，又可写
+ ServerSocketChannel用来监听客户端连接请求并创建SocketChannel与客户端进行通信
+ 只能通过Buffer读写Channel中数据

## Buffer

本质上是一块内存区域

**字段**

```java
private int mark = -1; // 存储特定position位置，后续通过reset恢复到该位置，依然可以读取这里的数据
private int position = 0; // 读写操作时的索引下标，最大为capacity-1;写模式切换到读模式时，会变为0
private int limit; // 写模式下等于capacity，切换到读模式时，limit表示最多能从buffer中读取多少，等于写模式下的position
private int capacity; // 容量，标识最大能容纳多少字节
```

**API实例**

```java
ByteBuffer byteBuffer = ByteBuffer.allocate(10); // position = 0,limit = 10,capacity=10
byteBuffer.put("aaa".getBytes()); // position = 3, limit = 10, capacity = 10
byteBuffer.flip(); // 从写模式切换到读模式 position = 0, limit = 3, capacity = 10
byteBuffer.get();  // position = 1, limit = 3, capacity = 10
byteBuffer.mark(); // mark = 1, position = 1, limit = 3, capacity = 10
byteBuffer.get();  // mark = 1, position = 2, limit = 3, capacity = 10
byteBuffer.reset();  // mark = 1, position = 1, limit = 3, capacity = 10
byteBuffer.clear(); // 所有属性重置 position = 0, limit = 10, capacity = 10
```

使用Java NIO Buffer类的基本步骤如下：
（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。
（2）调用put()方法将数据写入缓冲区中。
（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。
（4）调用get()方法，可以从缓冲区中读取数据。
（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。

## Selector

**选择器** /**多路复用器**。用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。

## 示例程序

**NIOServer**

```java
package io;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    public void start() throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.bind(new InetSocketAddress(8848));
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        while (true) {
            int readyChannels = selector.select(); // 获取可用channel数量
            if (readyChannels == 0) {
                continue;
            }
            Set<SelectionKey> selectionKeys = selector.selectedKeys();
            Iterator<SelectionKey> iterator = selectionKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey selectionKey = iterator.next();
                iterator.remove();
                if (selectionKey.isReadable()) {
                    readHandler(selectionKey, selector);
                } else if (selectionKey.isAcceptable()) {
                    acceptHandler(serverSocketChannel, selector);
                }
            }
        }
    }

    private void acceptHandler(ServerSocketChannel serverSocketChannel, 
                               Selector selector) throws IOException {
        SocketChannel socketChannel = serverSocketChannel.accept();
        socketChannel.configureBlocking(false);
        socketChannel.register(selector, SelectionKey.OP_READ);
        // encode返回的是ByteBuffer
        socketChannel.write(Charset.defaultCharset().encode("成功连上了服务器!"));
    }

    private void readHandler(SelectionKey selectionKey, 
                             Selector selector) throws IOException {
        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        // 读取客户端数据
        StringBuilder msg = new StringBuilder();
        while (socketChannel.read(byteBuffer) > 0) {
            byteBuffer.flip();
            msg.append(Charset.defaultCharset().decode(byteBuffer));
        }
        // 将channel再次注册到selector上,监听它的可读事件
        socketChannel.register(selector, SelectionKey.OP_READ);
        if (msg.length() > 0) {
            System.out.println(msg.toString());
            broadCast(selector, socketChannel, msg.toString());
        }
    }

    private void broadCast(Selector selector, SocketChannel sourceChannel, String msg) {
        // 获取所有已接入客户端channel
        Set<SelectionKey> selectionKeys = selector.keys();
        selectionKeys.forEach(selectionKey -> {
            Channel targetChannel = selectionKey.channel();
            // 剔除发消息的那个channel
            if (targetChannel instanceof SocketChannel 
                && targetChannel != sourceChannel) {
                try {
                    // 向所有channel广播信息
                    ((SocketChannel) targetChannel).write(Charset.defaultCharset().encode(msg));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public static void main(String[] args) throws IOException {
        new NIOServer().start();
    }
}
```

**NIOClient**

```java
package io;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Set;

public class NIOClient {
    static class NIOClientHandler implements Runnable {
        private final Selector selector;

        public NIOClientHandler(Selector selector) {
            this.selector = selector;
        }

        @Override
        public void run() {
            try {
                while (true) {
                    int readyChannels = selector.select(); // 获取可用channel数量
                    if (readyChannels == 0) {
                        continue;
                    }
                    Set<SelectionKey> selectionKeys = selector.selectedKeys();
                    Iterator<SelectionKey> iterator = selectionKeys.iterator();
                    while (iterator.hasNext()) {
                        SelectionKey selectionKey = iterator.next();
                        iterator.remove();
                        if (selectionKey.isReadable()) {
                            readHandler(selectionKey, selector);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        private void readHandler(SelectionKey selectionKey, 
                                 Selector selector) throws IOException {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
            // 读取服务器端响应数据
            StringBuilder msg = new StringBuilder();
            while (socketChannel.read(byteBuffer) > 0) {
                byteBuffer.flip();
                msg.append(Charset.defaultCharset().decode(byteBuffer));
            }
            // 将channel再次注册到selector上,监听它的可读事件
            socketChannel.register(selector, SelectionKey.OP_READ);
            if (msg.length() > 0) {
                System.out.println(msg.toString());
            }
        }
    }

    public void start() throws IOException {
        SocketChannel socketChannel = 
            SocketChannel.open(new InetSocketAddress("127.0.0.1", 8848));
        // 新开线程，专门接收服务器端发送的信息
        Selector selector = Selector.open();
        socketChannel.configureBlocking(false);
        socketChannel.register(selector, SelectionKey.OP_READ);
        new Thread(new NIOClientHandler(selector)).start();

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextLine()) {
            String msg = scanner.nextLine();
            if (msg != null && msg.length() > 0) {
                socketChannel.write(Charset.defaultCharset().encode(msg));
            }
        }
    }

    public static void main(String[] args) throws IOException {
        new NIOClient().start();
    }
}
```



# AIO

Asynchronous I/O或NIO.2

异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理

**AIO**提供了从建立连接到读、写的全异步操作。**AIO**可用于异步的**文件读写**和**网络通信**。

**Server**

```java
package io;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

public class AIOServer {
    public static void main(String[] args) {
        try {
            final int port = 8848;
            AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();
            serverSocketChannel.bind(new InetSocketAddress(port));
            // 需要在handler的实现中处理连接请求和监听下一个连接、数据收发，以及通信异常。
            // 消息处理回调接口，是一个负责消费异步IO操作结果的消息处理器
            CompletionHandler<AsynchronousSocketChannel, Object> handler = new CompletionHandler<AsynchronousSocketChannel, Object>() {
                /*
                当I/O操作成功完成时，会回调到completed方法，failed方法则在I/O操作失败时被回调。
                需要注意的是：在CompletionHandler的实现中应当及时处理操作结果，以避免一直占用调用线程而不能分发其他的CompletionHandler处理器。
                 */
                @Override
                public void completed(AsynchronousSocketChannel result, Object attachment) {
                    // 继续监听下一个连接请求
                    serverSocketChannel.accept(attachment, this);
                    try {
                        System.out.println("接受了一个连接：" + result.getRemoteAddress().toString());
                        // result表示当前接受的客户端的连接会话，与客户端的通信都需要通过该连接会话进行。
                        result.write(Charset.defaultCharset().encode("Server:Hello World"));

                        ByteBuffer readBuffer = ByteBuffer.allocate(128);
                        result.read(readBuffer).get();
                        System.out.println(new String(readBuffer.array()));
                    } catch (IOException | InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                }

                @Override
                public void failed(Throwable exc, Object attachment) {
                    System.out.println("出错了：" + exc.getMessage());
                }
            };
            // 是一个异步方法，调用会直接返回,为了让子线程能够有时间处理监听客户端的连接会话，这里让主线程休眠一段时间
            serverSocketChannel.accept(null, handler);
            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Client**

```java
package io;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.Charset;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

public class AIOClient {
    public static void main(String[] args) {
        try {
            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();
            client.connect(new InetSocketAddress("127.0.0.1", 8848), null, new CompletionHandler<Void, Object>() {
                @Override
                public void completed(Void result, Object attachment) {
                    System.out.println("成功连接到服务器!");
                    try {
                        client.write(Charset.defaultCharset().encode("Client:Hello World"));
                        ByteBuffer readBuffer = ByteBuffer.allocate(128);
                        client.read(readBuffer).get();
                        System.out.println(new String(readBuffer.array()));
                    } catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                }

                @Override
                public void failed(Throwable exc, Object attachment) {
                    exc.printStackTrace();
                }
            });
            TimeUnit.MINUTES.sleep(Integer.MAX_VALUE);
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

